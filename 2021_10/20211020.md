# 211020(수)

# 오늘 공부한 것

- 패캠 JS 특강

# 기억해야 할 것

### 얕은 복사

```jsx
const user = {
  // 1depts
  id: "1",
  name: "KSH",
  age: 26,
  license: [
    // 2depts
    { name: "1종보통", isValid: true }, // 3depts
    { name: "트레일러", isValid: true },
  ],
};

const cloneUser = {
  ...user,
};
cloneUser.age = 90;
console.log(user); // {id: "1", name: "KSH", age: 26, license: Array(2)}
console.log(cloneUser); // {id: "1", name: "KSH", age: 90, license: Array(2)}

// 얼핏 보기에는 cloneUser에서 수정한 내용은 cloneUser에만 잘 적용되는것 처럼 보인다(age)
```

```jsx
// 하지만 더 깊이 있는 객체의 내용을 수정하게 된다면?
cloneUser.license[0].isValid = false;
console.log(user.license);
// [{name: "1종보통", isValid: false}, {name: "트레일러", isValid: true}]
console.log(cloneUser.license);
// [{name: "1종보통", isValid: false}, {name: "트레일러", isValid: true}]

// clonUser에서 수정한 내용이 원래 객체 user에도 영향을 미치게 되었다.
```

- 위와 같은 현상이 발생되는 이유는 1depts인 id, name, age, license모양 까지는 따로 복사가 잘 되지만 (참조하는 메모리의 위치가 바뀌지만)
- licesnse안에 배열, 배열의 각 요소인 객체들은 user와 cloneUser 모두 같은 메모리를 바라보고 있기 때문에 위처럼 cloneUser값을 수정해도 user에 영향을 미치게 된다.

### 깊은 복사

- 위와 같은 문제를 해결하는 방법은 모든 depts를 완전히 새롭게 깊~게 복사하는 것이다.
- 이는 lodash에서 제공하는 cloneDeep 기능을 활용하면 손쉽게 깊은 복사를 할 수 있다.
- 이런 복사 방식은 객체의 모든 요소가 메모리를 완전히 새롭게 차지하기 때문에 메모리 낭비가 발생 할 수 있으므로 상황에 따라 잘 선택하여 활용해야 한다.

```jsx
const deepUser = _.cloneDeep(user);
deepUser.age = 90;
console.log(user); // {id: "1", name: "KSH", age: 26, license: Array(2)}
console.log(deepUser); // {id: "1", name: "KSH", age: 90, license: Array(2)}

deepUser.license[0].isValid = false;
console.log(user.license);
// [{name: "1종보통", isValid: true}, {name: "트레일러", isValid: true}]
console.log(deepUser.license);
// [{name: "1종보통", isValid: false}, {name: "트레일러", isValid: true}]

// 이제 더이상 deeUser에서 수정한 내용이 user에 영향을 끼치지 않는다.
```

## DOM

### querySelector

- 조건에 부합하며 제일 먼저 검색된 요소를 가져옴

### querySelectorAll

- 조건에 맞는 요소 모두 가져옴
- nodelist형식으로 나오며 nodelist는 유사 배열이다.

### getElementById

- id로 요소를 찾아 가져옴.
- 이때 #은 안써도 됨 (id 그 자체만 적음)
- `const Adiv = document.getElementById('A')`

### DOM 프로퍼티

```jsx
const Adiv = document.getElementById("A");
// parentNode
console.log(Adiv.parentNode); // Adiv의 부모요소

//nextElementSibling
console.log(Adiv.nextElementSibling); // Adiv의 다음 형제 요소

//previousElementSibling
console.log(Adiv.previousElementSibling); // Adiv의 이전 형제 요소

// 누적사용 가능하다.
console.log(Adiv.parentNode.parentNode.parentNode);
// Adiv의 부모요소의 부모요소의 부모요소

// 요소가 더이상 없을 경우 null을 리턴한다.
```

### Setter, Getter

```jsx
const Adiv = document.getElementById("A");

Adiv.id = "aaa"; // Setter -> Adiv의 id를 세팅
console.log(Adiv.id); // Getter -> Adiv의 id를 가져옴

Adiv.className = "AClass aaa"; // Setter -> Adiv의 class를 세팅
console.log(Adiv.className); // Getter -> Adiv의 class를 가져옴
```

- id, className은 그 부분의 내용을 싹 바꾸는 것이다.
  즉, `<div id='A' class='a'></div>` -> `<div id='aaa' class='AClass aaa'></div>` 이다.
- id, className모두 띄어쓰기를 사용시 그만큼의 id, class를 가지게 된다.
  즉, 위의 Adiv는 AClass, aaa 두개의 클래스를 가진다.
- className은 classList가 생기면서 잘 안쓰이게 되었고 현재는 거의 Getter형식으로만 사용된다. (클래스명을 알아볼때)

### classList

- classList는 `classList.add('추가할 클래스명')`, `classList.remove('추가할 클래스명')`, `classList.contains('확인할 클래스명')` 으로 사용된다.
- contains는 불린값을 리턴한다.

### setAttribute, getAttribute

- 요소의 속성을 다룰 수 있다.

```jsx
Adiv.setAttribute("id", "setID"); // id를 setID로 바꿈
console.log(Adiv.getAttribute("id")); // setID -> id값을 가져옴
```

- 역시 한번에 여러 id, class명을 추가 가능하다.

### textContent

- 요소가 포함하는 **text부분만** 보여줌
- `console.log(Adiv.textContent)` → A

### innerHTML

- HTML 구조를 생성 할 수 있음

```jsx
const ulEl = document.querySelector("ul");
ulEl.innerHTML = "<li>1</li> <li>2</li> <li>3</li>";
```

```html
<ul>
  <li>::maker "1"</li>
  <li>::maker "2"</li>
  <li>::maker "3"</li>
</ul>
```

### createElement

- 요소 만들어서 메모리에 넣어둠
- `const liEl = document.createElement('li')`

### prepend

- 기준요소의 내부에 가장 앞에 추가함

### append

- 기준요소의 내부에 가장 뒤에 추가함

### remove

- 요소를 삭제함

### addEvnetListener, removeEventListner

- remove를 하기위해서는 지울것이 명확하게 있어야 한다. 할당된 함수 or 그냥 선언된 함수 처럼
- 즉, 바로 콜백함수를 작성하는 경우에는 모양이 완전히 똑같아도 같은 함수가 아니므로 remove되지 않는다.

### preventDefault()

- 요소가 가지고 있는 기본 동작들을 막을 수 있다.
- form의 submit 이나 마우스 우클릭시 발생하는 기본 이벤트 등

### event bubbling

- 이벤트가 계속 상위요소로 퍼져나가는 것을 말한다.
-

# 정리

# 220520(금)

# 오늘 공부한 것

- Deep dive 25 클래스

# 기억해야 할 것

### 25.8 상속에 의한 클래스 확장

**25.8.2. extends 키워드**

- extends 키워드를 사용하여 수퍼클래스와 서브 클래스 간의 상속 관계를 설정하면 인스턴스의 프로토타입 체인뿐 아니라 클래스 간의 프로토타입 체인도 생성하여 프로토타입 메서드, 정적 메서드 모두 상속하게 된다.

**25.8.3 동적 상속**

- extends 키워드에 뒤에 오는 즉, 상속을 해주는 요소로 클래스 뿐만 아니라 생성자 함수를 입력하여 상속이 가능하다.
- 뿐만아니라 [[Construct]] 내부 메서드를 갖는 함수 객체로 평가될 수 있는 모든 표현식을 사용할 수 있다.
- 단, extens 키워드 앞에는 항상 클래스가 와야 한다.

```jsx
// 생성자 함수
function Fire(name) {
  this.name = name;
}
Fire.prototype.type = function () {
  return "fire";
};

// 클래스
class Water {
  constructor(name) {
    this.name = name;
  }

  type() {
    return "water";
  }
}

// 조건에 따라 동적으로 상속 가능
const name = "꼬부기";
let isWater = name === "꼬부기" ? true : false;

class Poketmon extends (isWater ? Water : Fire) {}
const poketmon = new Poketmon(name);
console.log(poketmon); // Poketmon {name: '꼬부기'}
console.log(poketmon.type()); // water
```

**25.8.4 서브클래스의 constructor**

- 만약 서브클래스에서 constructor 를 선언하지 않으면 constructor는 암묵적으로
  `constructor(…args){super(…args);}` 처럼 정의된다.
- super는 수퍼클래스의 constructor를 호출하여 인스턴스를 생성한다.

> 일반 클래스에서 constructor를 생략하면 `constructor() {}` 가 암묵적으로 생성

**25.8.5 super 키워드**

- super 키워드는 함수처럼 호출할 수도 있고 `super()` 식별자 처럼 참조를 할 수도 있다. `supser.hi()`

**super 호출**

- super 호출 시 수퍼 클래스의 constructor를 호출하여 인스턴스를 만들게 된다.
- super 호출시 주의할 점

1. 서브 클래스에서 constructor를 생략하지 않은 경우 항상 super를 호출해주어야 한다.

```jsx
// 슈퍼 클래스에서 constructor가 생략되었지만 서브 클래스에서는 constructor를 생략하지 않음
class Pocketmon {}

class Fire extends Pocketmon {
  constructor(name, type) {
    // super(); => 생략하게 되면 에러 발생
    /* ReferenceError: Must call super constructor in derived class 
			before accessing 'this' or returning from derived constructor
    */
    this.name = name;
    this.type = type;
  }
}

const 파이리 = new Fire("파이리", "fire");
console.log(파이리);
```

```jsx
class Pocketmon {
  constructor(name, type) {
    this.name = name;
    this.type = type;
  }
}

// 반대로 서브 클래스에서 constructor를 생략할 경우에는 super를 호출하지 않아도 된다.
// 알아서 constructor가 생성되고 슈퍼클래스의 constructor를 이용하여 인스턴스를 생성한다.
class Fire extends Pocketmon {}

const 파이리 = new Fire("파이리", "fire");
console.log(파이리); // Fire {name: '파이리', type: 'fire'}
```

1. 서브 클래스의 constructor에서 super를 호출하기 전에는 this를 참조할 수 없다.
   위 에러 메시지에서도 확인할 수 있듯이 this를 super가 실행되기전에는 참조할 수 없다.

```jsx
class Pocketmon {
  constructor(name) {
    this.name = name;
  }
}

class Fire extends Pocketmon {
  constructor(name, type) {
    this.type = type; // 위와 같은 에러 발생
    super(name);
  }
}

const 파이리 = new Fire("파이리", "fire");
console.log(파이리);
```

1. super는 반드시 서브클래스의 constructor 안에서 호출되어야 한다.
   일반 클래스나, 함수에서 super를 호출하면 에러가 발생한다.

```jsx
// 일반 클래스에서 super 사용 X
class Pocketmon {
  constructor(name) {
    super(); // SyntaxError: 'super' keyword unexpected here
    this.name = name;
  }
}
```

**super 참조**

- 서브클래스의 메서드, 정적 메서드 안에서 super를 이용하여 수퍼클래스의 메서드를 호출할 수 있다.
- 단, super 참조는 메서드에서는 메서드만, 정적 메서드에서는 정적메서드만 참조가 가능하다.

```jsx
class Pocketmon {
  constructor(name) {
    this.name = name;
  }

  attack() {
    return "효과는 굉장했다!!";
  }

  static hi() {
    return "안녕";
  }
}

class Fire extends Pocketmon {
  constructor(name, type) {
    super(name);
    this.type = type;
  }

  attack() {
    console.log(`${this.name}의 공격! ${super.attack()}`);
    console.log(super.hi()); // TypeError: (intermediate value)
    // 일반 메서드에서 슈퍼 클래스의 정적 메서드 참조시 에러 발생
  }

  static Hello() {
    console.log(super.hi()); // 안녕
    console.log(super.attack()); // TypeError: (intermediate value)
    // 마찬가지로 정적메서드에서 슈퍼 클래스의 일반 메서드 참조시 에러 발생
  }
}

const 파이리 = new Fire("파이리", "fire");
파이리.attack(); // 파이리의 공격! 효과는 굉장했다!!
Fire.Hello();
```

# 정리

내용이 DEEP 하므로 좀 더 공부해서 추가할 예정
